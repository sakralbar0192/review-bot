## **Архитектурный стиль**
	**Clean Architecture + DDD + Event-Driven** с чёткими границами контекстов и CQRS для операций чтения/записи.

---

## **1. Core Domain: Review Assignment Context**
*Ядро системы — управление жизненным циклом ревью*

### **Агрегаты:**
```typescript
// КОРНЕВОЙ АГРЕГАТ
class ReviewSession {
  constructor(
    public id: ReviewSessionId,
    public mrInfo: MRInfo,              // Value Object
    public currentReviewerId: DeveloperId | null,
    public status: ReviewStatus,        // "searching" | "assigned" | "in_review" | "completed"
    public assignmentAttempts: number,  // попытки назначения
    public createdAt: Timestamp,
    public assignedAt: Timestamp | null,
    public deadline: Timestamp | null   // дедлайн 4 часа
  ) {}
  
  // КОМАНДЫ
  assignReviewer(developerId: DeveloperId): void {
    this.currentReviewerId = developerId;
    this.status = "assigned";
    this.assignedAt = now();
    this.assignmentAttempts++;
    this.addDomainEvent(new ReviewerAssignedEvent(this.id, developerId));
  }
  
  confirmAssignment(): void {
    this.status = "in_review";
    this.deadline = now() + 4.hours();
    this.addDomainEvent(new ReviewStartedEvent(this.id));
  }
  
  complete(): void {
    this.status = "completed";
    this.addDomainEvent(new ReviewCompletedEvent(this.id));
  }
  
  markAsTimeout(): void {
    this.currentReviewerId = null;
    this.status = "searching";
    this.addDomainEvent(new ReviewTimeoutEvent(this.id));
  }
  
  // ИНВАРИАНТЫ
  invariant(): void {
    // Разработчик не может ревьюить свой MR
    if (this.currentReviewerId === this.mrInfo.authorId) {
      throw new BusinessRuleViolation("Reviewer cannot be MR author");
    }
    
    // Максимум 3 попытки назначения
    if (this.assignmentAttempts > 3) {
      throw new BusinessRuleViolation("Max assignment attempts reached");
    }
  }
}

// VALUE OBJECT
class MRInfo {
  constructor(
    public readonly mrId: string,      // ID из GitLab
    public readonly url: string,
    public readonly title: string,
    public readonly authorId: DeveloperId
  ) {}
}
```

### **Сервисы домена:**
```typescript
class ReviewAssignmentService {
  async findReviewerFor(session: ReviewSession): Promise<DeveloperId> {
    // Запрос в Developer Context
    const availableDevelopers = await this.developerService
      .findAvailableDevelopers([session.mrInfo.authorId]);
    
    // Алгоритм выбора (минимальная нагрузка за неделю)
    const selected = availableDevelopers
      .sort((a, b) => a.weeklyLoad - b.weeklyLoad)
      [0];
    
    return selected.id;
  }
}
```

### **Репозиторий:**
```typescript
interface IReviewSessionRepository {
  findById(id: ReviewSessionId): Promise<ReviewSession>;
  findByMRId(mrId: string): Promise<ReviewSession | null>;
  findActiveSessions(): Promise<ReviewSession[]>;
  save(session: ReviewSession): Promise<void>;
}
```

---

## **2. Core Domain: Developer Context**
*Управление разработчиками, их статусами и нагрузкой*

### **Агрегаты:**
```typescript
class Developer {
  constructor(
    public id: DeveloperId,
    public name: string,
    public currentLoad: number,      // активные ревью
    public weeklyLoad: number,       // завершённые за неделю
    public availability: AvailabilityStatus, // "available" | "focus_mode" | "vacation"
    public focusModeEndsAt: Timestamp | null,
    public lastFocusModeDate: Date | null, // для правила "1 раз в день"
    public expertiseTags: string[]   // ["frontend", "react", "typescript"]
  ) {}
  
  canAcceptReview(): boolean {
    return this.availability === "available" 
      && this.currentLoad === 0;     // одно ревью одновременно
  }
  
  enterFocusMode(durationHours: number): void {
    // Бизнес-правило: 1 фокус-окно в день
    if (this.lastFocusModeDate?.isToday()) {
      throw new BusinessRuleViolation("Focus mode already used today");
    }
    
    this.availability = "focus_mode";
    this.focusModeEndsAt = now() + durationHours.hours();
    this.lastFocusModeDate = new Date();
    this.addDomainEvent(new DeveloperEnteredFocusMode(this.id));
  }
  
  exitFocusMode(): void {
    this.availability = "available";
    this.focusModeEndsAt = null;
    this.addDomainEvent(new DeveloperExitedFocusMode(this.id));
  }
  
  increaseLoad(): void {
    this.currentLoad++;
  }
  
  decreaseLoad(): void {
    this.currentLoad--;
    this.weeklyLoad++;
  }
}
```

---

## **3. Supporting Domain: Notification Context**
*Бизнес-логика уведомлений и таймингов*

### **Обработчики событий:**
```typescript
class NotificationOrchestrator {
  @Subscribe(ReviewerAssignedEvent)
  async onReviewerAssigned(event: ReviewerAssignedEvent): Promise<void> {
    // 1. Немедленное уведомление
    await this.messagingService.send({
      userId: event.reviewerId,
      text: `Новое ревью: ${event.mrUrl}`,
      buttons: ["✅ Принять", "❌ Отказаться"]
    });
    
    // 2. Таймер на 30 мин для ответа
    await this.schedulingService.schedule({
      id: `response_${event.sessionId}`,
      after: "30m",
      type: "CHECK_RESPONSE",
      payload: { sessionId: event.sessionId }
    });
    
    // 3. Таймер на 2 часа для напоминания (если принял)
    await this.schedulingService.schedule({
      id: `reminder_${event.sessionId}`,
      after: "2h",
      type: "SEND_REMINDER",
      payload: { sessionId: event.sessionId }
    });
  }
  
  @Subscribe(TimerFiredEvent)
  async onTimerFired(event: TimerFiredEvent): Promise<void> {
    switch (event.type) {
      case "CHECK_RESPONSE":
        const session = await this.reviewRepo.findById(event.payload.sessionId);
        if (session.status === "assigned") {
          // Не ответил за 30 мин → помечаем как timeout
          session.markAsTimeout();
          await this.reviewRepo.save(session);
        }
        break;
        
      case "SEND_REMINDER":
        if (await this.shouldSendReminder(event.payload.sessionId)) {
          await this.messagingService.sendReminder(event.payload.sessionId);
          // Ставим следующий таймер (каждые 2 часа)
          await this.rescheduleReminder(event.payload.sessionId);
        }
        break;
    }
  }
}
```

---

## **4. Infrastructure: Messaging & Scheduling**

### **Абстракции:**
```typescript
// Порт для мессенджеров
interface IMessagingAdapter {
  sendMessage(params: MessageParams): Promise<MessageId>;
  listenForResponses(handler: (response: UserResponse) => void): void;
}

// Порт для таймеров
interface ISchedulingAdapter {
  scheduleTimer(params: TimerParams): Promise<TimerId>;
  cancelTimer(timerId: TimerId): Promise<void>;
}

// Конкретные реализации
class SlackAdapter implements IMessagingAdapter {
  async sendMessage(params: MessageParams): Promise<MessageId> {
    // Реализация для Slack API
  }
}

class RedisScheduler implements ISchedulingAdapter {
  async scheduleTimer(params: TimerParams): Promise<TimerId> {
    // Используем Redis Sorted Sets для персистентных таймеров
  }
}
```

---

## **5. Integration: GitLab Context**
*Анти-коррупционный слой для GitLab API*

```typescript
class GitLabWebhookHandler {
  @Post("/webhooks/gitlab")
  async handleWebhook(payload: GitLabWebhook): Promise<void> {
    switch (payload.event_type) {
      case "merge_request":
        await this.handleMergeRequest(payload);
        break;
      case "note": // комментарий в MR
        await this.handleComment(payload);
        break;
    }
  }
  
  private async handleMergeRequest(payload: any): Promise<void> {
    const command = this.mapToInternalCommand(payload);
    await this.commandBus.send(command);
  }
  
  // Маппинг внешней модели во внутреннюю
  private mapToInternalCommand(payload: any): CreateReviewSessionCommand {
    return {
      type: "CREATE_REVIEW_SESSION",
      mrId: payload.object_attributes.iid,
      url: payload.object_attributes.url,
      authorId: this.findDeveloperByGitLabId(payload.user.id),
      title: payload.object_attributes.title
    };
  }
}
```

---

## **6. Query Side: Statistics & Dashboard**
*CQRS - отдельная модель для чтения*

```typescript
// Проекции для быстрого чтения
class ReviewStatisticsProjection {
  @Subscribe(ReviewCompletedEvent)
  async onReviewCompleted(event: ReviewCompletedEvent): Promise<void> {
    // Обновляем материализованное представление
    await this.db.reviewStats.update({
      where: { developerId: event.reviewerId },
      data: {
        completedCount: { increment: 1 },
        totalTime: { increment: event.duration },
        avgTime: { /* пересчёт */ }
      }
    });
  }
}

// Готовые запросы для дашборда
class DashboardQueries {
  async getTeamPerformance(period: DateRange): Promise<TeamStats> {
    return this.db.$queryRaw`
      SELECT developer_id, 
             COUNT(*) as review_count,
             AVG(duration) as avg_time,
             SUM(CASE WHEN completed_in_time THEN 1 ELSE 0 END) as on_time_percentage
      FROM review_statistics
      WHERE completed_at BETWEEN ${period.start} AND ${period.end}
      GROUP BY developer_id
      ORDER BY review_count DESC
    `;
  }
}
```

---

## **7. Контракты между контекстами**

### **События (публикуются):**
```typescript
// Review Assignment Context публикует:
interface ReviewerAssignedEvent {
  type: "REVIEWER_ASSIGNED";
  sessionId: ReviewSessionId;
  reviewerId: DeveloperId;
  mrUrl: string;
  deadline: Timestamp; // 4 часа
}

// Developer Context публикует:
interface DeveloperAvailabilityChangedEvent {
  type: "DEVELOPER_AVAILABILITY_CHANGED";
  developerId: DeveloperId;
  newStatus: AvailabilityStatus;
  until: Timestamp | null;
}
```

### **Команды (принимаются):**
```typescript
// Review Assignment Context принимает:
interface CreateReviewSessionCommand {
  type: "CREATE_REVIEW_SESSION";
  mrId: string;
  authorId: DeveloperId;
  url: string;
}

// Notification Context принимает:
interface SendReminderCommand {
  type: "SEND_REMINDER";
  sessionId: ReviewSessionId;
  reminderType: "first" | "second" | "urgent";
}
```

---

## **8. Правила консистентности**

### **Strong Consistency (внутри агрегата):**
- Состояние ReviewSession (статусы, назначения)
- Состояние Developer (нагрузка, доступность)

### **Eventual Consistency (между контекстами):**
- Статистика обновляется асинхронно
- Уведомления отправляются асинхронно
- Дашборд может показывать устаревшие данные на 1-5 минут

---

## **9. Обработка ошибок и edge cases**

### **Стратегия повторов:**
```typescript
class RetryPolicy {
  static forGitLabAPI = {
    maxAttempts: 3,
    backoff: 'exponential',
    shouldRetry: (error) => !error.is4xx() // не повторяем клиентские ошибки
  };
  
  static forNotifications = {
    maxAttempts: 5,
    backoff: 'linear',
    fallback: async (message) => {
      // Отправляем в "проваленные уведомления" для ручной обработки
      await this.failedNotificationsQueue.add(message);
    }
  };
}
```

### **Компенсирующие транзакции:**
```typescript
// Если не удалось назначить ревьюера
async function compensateFailedAssignment(sessionId: ReviewSessionId): Promise<void> {
  // 1. Возвращаем сессию в статус "searching"
  // 2. Логируем инцидент
  // 3. Уведомляем администратора
  // 4. Пробуем альтернативный алгоритм
}
```

---

## **10. Структура проекта**
```
/src
  /contexts
    /review-assignment           # Core Domain
      /domain
        /aggregates
          ReviewSession.ts
          MRInfo.ts
        /services
          ReviewAssignmentService.ts
        /events
          ReviewerAssigned.ts
        /repositories
          IReviewSessionRepository.ts
      /application
        /commands
          CreateReviewSessionCommandHandler.ts
        /queries
      /infrastructure
        /persistence
          PrismaReviewSessionRepository.ts
    
    /developers                  # Core Domain
      /domain
        /aggregates
          Developer.ts
      /infrastructure
        /api
          DeveloperHTTPController.ts
    
    /notifications               # Supporting Domain
      /domain
        /services
          NotificationOrchestrator.ts
      /application
        /event-handlers
    
    /gitlab-integration          # Anti-Corruption Layer
      /adapters
        GitLabWebhookAdapter.ts
        GitLabAPIAdapter.ts
    
    /analytics                   # Supporting Domain (CQRS)
      /projections
        ReviewStatisticsProjection.ts
      /queries
        DashboardQueries.ts
  
  /infrastructure
    /messaging
      SlackAdapter.ts
      TeamsAdapter.ts
    /scheduling
      RedisScheduler.ts
    /event-bus
      RabbitMQEventBus.ts
  
  /shared
    /domain
      ValueObjects.ts
      Identifiers.ts
    /application
      CommandBus.ts
      QueryBus.ts
```

---

## **Ключевые инсайты дизайна:**

1. **Ядро изолировано** от инфраструктурных деталей
2. **Каждый контекст автономен** с чёткими контрактами
3. **Event-Driven** для слабой связности
4. **CQRS** для разделения операций записи и чтения
5. **Анти-коррупционные слои** защищают домен от внешних изменений
6. **Явная обработка ошибок** с компенсирующими транзакциями

## **Следующие шаги:**

1. Начать с **Event Storming** для каждого контекста отдельно
2. Реализовать **скелет агрегатов** с инвариантами
3. Настроить **Event Bus** между контекстами
4. Создать **интеграционные тесты** для контрактов
5. Постепенно добавлять **инфраструктурные адаптеры**

Этот дизайн обеспечит **масштабируемость**, **тестируемость** и **гибкость** для будущих изменений требований.